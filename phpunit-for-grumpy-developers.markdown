{mainmatter}

# PHPUnit For Grumpy Developers
PHPUnit can look intimidating, even to just get the skeleton of a test created, due
to the immense length of it's documentation and large number of configurable
options. Don't be scared though, I am here to help!

You can start with just a few of the basics before moving on to more complicated setups that include options for
skipping certain types of tests or changing default settings.

To be honest, the defaults will cover 99.999% of your testing needs.

## Installing And Configuring
Installing PHPUnit and its associated (sometimes optional) dependencies has
gotten easier and easier with each passing day. As I write this book in the
Canadian winter of 2012-2013, I have two preferred ways of installing PHPUnit that I
would recommend.

### Installing via Composer
[Composer](http://getcomposer.org/) is a command-line tool for tracking and
installing dependencies for your application. In my opinion, Composer
is transforming the way PHP developers build their PHP applications, making it easier to install dependencies
and external libraries. With all the major frameworks supporting it,
there is no reason not to use it if you are running PHP 5.3 or greater.

To install PHPUnit using Composer, once you've installed Composer itself, create a JSON file (commonly named composer.json) that tells Composer where you want it installed.

Here's an example that will install PHPUnit globally in the specified 'config' directory.

{lang : json}
    {
        "name": "phpunit",
        "description": "PHPUnit",
        "require": {
            "phpunit/phpunit": "3.7.*"
        },
        "config": {
            "bin-dir": "/usr/local/bin/"
        }
    }   

Composer will also try to pull in any required dependencies, but if for
some reason they don't work, you can just add them to composer.json.

If you prefer to have PHPUnit as an actual dependency for your application,
you can create a much simplified version of that JSON file

{lang: "json"}
    {
        "require-dev": {
            "phpunit/phpunit": "3.7.*"
        }
    }

This will result in PHPUnit being available *inside* your project, in the
vendor directory. 

It's a tough call. On the one hand, you don't want to force people to
install PHPUnit just to use your project. On the other hand, it does ensure
that you can update PHPUnit independent of any other versions you already had
installed.

### Installing via PEAR
[Pear](http://pear.php.net) used to be my preferred method of installation
before they made it available via Composer. In this case, installing things
can be as simple as:

{: lang }
    path/to/pear config-set auto_discover 1
    path/to/pear install pear.phpunit.de/PHPUnit 

By default PEAR will try to pull in additional dependencies for PHPUnit, 
but you can manually install any additional missing components via PEAR as well.

### Which One Should I Use
That depends on what additional dependencies you happen to be including. I definitely
think you should choose one method and stick with it, however, as mixing Composer and PEAR
might cause you to make mistakes and forget a package that you are likely
to need. Its worth noting that Composer installs dependencies locally by default while PEAR
does global installs.

In any case, consult the documentation for PHPUnit to see all the dependencies
and add-ons that are available.

## Minimum Viable Test Class 
{lang : php }
    <?php
    class GrumpyTest extends PHPUnit_Framework_TestCase
    {
        public function testMinimumViableTest()
        {
            $this->assertTrue(false, "true didn't end up being false!");
        }
    }

That is what I would call a Minimum Viable Test class. All test classes
need to extend off of the base PHPUnit_Framework_TestCase class, although
it is common for people to create their *own* base class that extends from
this one, and then all their test cases extend from it. Sounds like we are
getting to [Inception](http://en.wikipedia.org/wiki/Inception) levels of
class construction. 

All the built in assertions that PHPUnit provides follow the same pattern:

* a type of assertion
* an expected value
* the value generated by the test
* an optional message to be displayed when the test fails

I can already tell that you are thinking "he's lying about the pattern because
it says 'assertTrue'. In a way you are right. PHPUnit does provide some
shortcuts to perform certain assertions. assertTrue() is one of them, along
with it's counterpart assertFalse(). These shortcuts do not change the fact
that they all follow the same pattern.

For more details on all the assertions that are available to you, check
the [latest documentation](http://www.phpunit.de/manual/3.7/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.assertions).

## Making Your Tests Tell You What's Failed
A friend of mine related a story to me about an experience he had in a
team he was working with:

> Today I was called in as the unit tests stopped somewhere in the beginning 
> of the unit test run. I was really blown away to see the many
> E, F, I and S characters in the overview but I was more amazed about the 
> fact that my team had no idea how to figure out which test caused
> the fatal error

Now, I mentioned that all these assertions take, as their final argument, an 
optional message to be displayed if the test fails. I cannot recommend highly
enough that you make that message mandatory when you write your own tests. A
descriptive message will go a long way towards helping you figure out exactly
which test failed, hopefully telling you why.

There is also another option that doesn't involve using the optional message
argument. You could use PHPUnit's [TestDox](http://www.phpunit.de/manual/3.7/en/other-uses-for-tests.html)
functionality. What it does is turn the name of your test methods into easily-read
strings. 

It could turn testBankBalanceCannotGoIntoOverdraftUnlessAllowed into "Bank balance cannot
go into overdraft unless allowed". But be careful: if you have tests that have
the same name but you append an integer to the end, TestDox does not know
that the two are different.

My advice: stick to using the optional message argument, but TestDox is a
great option if your tests haven't been following my advice. At least you
will know what test in particular is reporting failures.

## Configuring Run Time Options
If you run 'phpunit --help' from the command line, you will see a
ridiculous number of options that are available to you. Some of them are
useful, others seem to be in there because the author was looking for
compatibility with existing tools. Here are the ones that I have found most
useful:

### Logging Options
If you are using PHPUnit in conjunction with a continuous integration
solution like [Jenkins-CI](http://www.jenkins-ci.org) then you should use 
the *--log-junit optional/path/to/file* switch. 

By spitting out logs in JUnit's XML format you make it easier for Jenkins plugins
to grab that data and do something useful with it.

### Code Coverage Options
Code coverage reports are a tool you can use to figure out how much
of your code is being executed by your tests. This value is normally
expressed as a percentage as in "I have 60% code coverage for my application...
why is Chris glaring at me like that?"

You also can get what is known as the Change Risk Analysis and Predictions
metric for your code. The CRAP score (I cannot think of a more appropriate
acronym) is an indication of how complex it is. The higher the CRAP score,
the more complicated your code is.

In order to generate a code coverage report, you need to have 
[the PHP CodeCoverage component](http://github.com/sebastianbergmann/php-code-coverage)
and [XDebug](http://xdebug.org) installed. 

There are two you need to consider:

Use *--coverage-clover optional/path/to/file* for generating Clover-formatted
reports that can be read by Jenkins code coverage plugins.

Clover-formatted reports can be used to examine trends over time in terms of
code coverage and lines of code added. Extremely useful if you are trying to
make sure developers are living up to their promises of writing tests with
maximum code coverage.

Use *--coverage-html optional/path* to create a series of HTML files that you
can view in your browser to see code coverage results.

### Managing Global State 
Many PHP applications make use of singletons that have static method calls,
or rely on globals and super-globals (like $_SESSION or $_POST, etc). While there
are legitimate reasons from an architectural standpoint to use static
methods, they are kryptonite when it comes to testing. Static classes, 
attributes, and variables are also considered part of the global state.

The problem? You often have no control over when and to what values these
things can be set. PHPUnit offers you a few ways to handle this. First, 
by default, PHPUnit tries to run your tests in such a way that it isolates
any changes made to global items, so you are somewhat covered there.

If you are using PHP 5.3 or greater, PHPUnit will give you the option to
also backup and restore static attributes of user defined classes. Again,
a good practice to allow for isolated tests.

My advice to you is avoid statics as much as possible. The backup-and-restore
mechanism will increase memory usage and test execution time, and statics
are all about trying to impose immutability in a language that likes everything
to be dynamic.

So, if you do need to use them, here are some tips:

* *--no-globals-backup* will disable the default backup-and-restore $GLOBALS
* *--static-backup* will backup and restore static attributes by default
* *@backupGlobals* annotation can be used to temporarily disable the backup-and-restore functionality for globals
* *@backupStaticAttributes* does the same, but for static attributes

### Process Isolation
Sometimes you are testing functionality that needs to be isolated while
testing. Things like class autoloaders, the session super-global, and header
output can all act weirdly under normal test conditions so they need a little help
to create the proper environment.

Use the *--process-isolation* switch to tell PHPUnit to run all your tests
in their own PHP instance. This has the disadvantage of not being configurable
for individual test cases, consuming more memory, and taking longer to
execute.

## Test Environment Configuration
It will quickly get tedious if you have to keep manually adding
command-line switches when running your tests. By default, PHPUnit will look
for a file called *phpunit.xml* whenever it runs and will then look at the
values inside it.

There are times when you will need different configuration files to run
different kinds of tests, unit tests vs. integration is the most common scenario.
You can have multiple configuration files, just make sure to call the one
that you want to us.

To execute your tests with a specific configuration file do:

{lang: text}
    /path/to/phpunit --configuration /path/to/your/phpunit.xml

### Command-Line Switches 
{ lang: xml}
    <phpunit 
        backupGlobals="true"
        processIsolation="false">
    <!-- other stuff goes here -->
    </phpunit>

Appendix C of the current PHPUnit documentation covers this in more detail.
I highly recommend setting as many of the command-line switches as you can
in the configuration file so you don't forget to do it yourself. Remember,
computers are awesome at doing what you tell them to over and over again.
Humans, not so much.

### Process Isolation
If you've worked with PHP for any length of time, you become aware of
the fact that there is global state, and that the state is preserved for
the entire length of the request. In other words, if you create an 
object at any point in the request, it will be available to any other
code that resides in the same scope.

This can sometimes be a problem when running tests because you don't
want state leaking from one test to another. Things could get unpredictable
if you modify an object in one test when a subsequent test expects that object
to be unmodified.

More commonly I have seen process isolation used in PHPUnit when
running integration tests. Why? Integration tests usually consist of
manipulating real objects, not test doubles, so you must pay close
attention to their state.

To insist on process isolation for all your tests, it's as simple as passing
*--process-isolation* as a CLI option, or setting *processIsolation="true"* in
your XML configuration file. This means, by default, every single test will
be run in it's own PHP process. This means your test suite will take a
lot longer to run, so keep this in mind if you decide to do it.

If you only have some tests that need to be isolated, it's a little bit
trickier. First, you need to add the annotation *@runInSeparateProcess*
to the docblock for your test that needs isolation. However, be aware that once you've
set that value, it will be preserved for all following tests.

To fix this, you would need to override the *run()* method in *PHPUnit_Framework_TestCase*
to explicitly turn the preservation of global state back off. Here's
an example.

{lang : php }
    <?php
    class GrumpyIsolatedTests extends PHPUnit_Framework_TestCase
    {
        public function run(PHPUnit_Framework_TestResult $result = NULL)
        {
            $this->setPreserveGlobalState(true);
            
            return parent::run($result);
        }
    }

Given that you have to do this bit of hackery, I would recommend overriding
the *run()* method in all your tests to explicitly set *preserveGlobalState*
to false. Such is the price of having selected process isolation.

Another potential solution is to use separate PHPUnit configuration
files that set process isolation as a run-time option and then
white list only the directories containing the tests that need
to be run in isolation. Conversely, make sure that your non-process-isolated
configuration file doesn't include any tests that require isolation
to work correctly.

My experience has been that the dual configuration file method
is the best way to go. 

## Organizing Your Tests

### File System
The easiest way to organize your tests is via the file system. Create a
directory for all your tests to run in, and PHPUnit will automatically
recursively traverse the directories below your root test directory to
find tests to run.

{ lang: text}
    Tests
    |-- Foo
    |   | -- Fizz
    |   |    `-- InputsTest.php
    |   | -- Buzz
    |   |    `-- RecursionTest.php 
    |   `-- BazzTest.php
    `-- FooTest.php    

This is normally the way I organize my tests.

### XML Configuration 
In a previous section I talked about creating an XML test suite file. You
can also specify exactly what tests you want run via XML. Let's create
a file that mirrors the structure we used above.

{ lang: xml}
    <phpunit>
        <testsuites>
            <testsuite named="Foo">
                <file>Tests/Foo/Fizz/InputsTest.php</file>
                <file>Tests/Foo/Buzz/RecursionTest.php</file>
                <file>Tests/Foo/BazzTest.php</file>
                <file>Tests/FooTest.php</file>
            </testsuite>
        </testsuites>
    </phpunit>

If you are working as part of a team that uses some sort of agile
development practice, I find the use of an XML file to be a good option. It
allows you the flexibility to prevent tests being run that might depend on code
fixes which have not yet been distributed to the rest of the team.

### Multiple Test Suites
One of the things that you will find if you start writing a large number
of tests for your application: some of those tests might be flaky due to
integration with 3rd party services you have not put wrappers around or
shared testing database servers that can get overloaded. These things,
while regrettable, are sometimes a reality for a resource-starved
development team.

Through the use of test suites you can create test plans
that you can choose to execute on an as-needed basis. To use the above
analogy, you might only want to run the flaky tests during the final set
of tests before a production push.

So how do we do this? First, you'd define your test suites:

{ lang: xml}
    <phpunit>
        <!-- other options -->
        <testsuites>
            <testsuite name="staging">
                <directory>./standard</directory>
            </testsuite>
            <testsuite name="preprod">
                <directory>./standard</directory>
                <directory>./integration</directory>
            </testSuite>
        </testsuites>
    </phpunit>

Let's say you want to only run the "staging" test suite. You would tell
PHPUnit via the CLI runner to do that like this: 

{ lang: text}
    /path/to/phpunit --testsuite staging
